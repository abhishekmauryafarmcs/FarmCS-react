const { createClient } = require('@supabase/supabase-js');

const supabaseUrl = 'https://tjgypejzectqcxznueqi.supabase.co';
// You'll need to get your service_role key from Supabase dashboard
// Go to Project Settings > API > service_role (secret)
const serviceRoleKey = 'YOUR_SERVICE_ROLE_KEY_HERE';

async function runMigration() {
  if (serviceRoleKey === 'YOUR_SERVICE_ROLE_KEY_HERE') {
    console.error('Please update the serviceRoleKey in this script with your actual service_role key from Supabase dashboard');
    console.log('Get it from: https://supabase.com/dashboard/project/tjgypejzectqcxznueqi/settings/api');
    return;
  }

  const supabase = createClient(supabaseUrl, serviceRoleKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  });

  const createUsersTableSQL = `
    CREATE TABLE IF NOT EXISTS users (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        first_name TEXT NOT NULL,
        last_name TEXT NOT NULL,
        mobile TEXT NOT NULL UNIQUE,
        state TEXT NOT NULL,
        district TEXT NOT NULL,
        password_hash TEXT NOT NULL,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );

    ALTER TABLE users ENABLE ROW LEVEL SECURITY;

    DROP POLICY IF EXISTS "Users can only view their own data" ON users;
    CREATE POLICY "Users can only view their own data" ON users
        FOR SELECT USING (auth.uid()::text = mobile);

    DROP POLICY IF EXISTS "Users can insert their own data" ON users;
    CREATE POLICY "Users can insert their own data" ON users
        FOR INSERT WITH CHECK (auth.uid()::text = mobile);

    DROP POLICY IF EXISTS "Users can update their own data" ON users;
    CREATE POLICY "Users can update their own data" ON users
        FOR UPDATE USING (auth.uid()::text = mobile);

    CREATE INDEX IF NOT EXISTS idx_users_mobile ON users(mobile);

    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
    END;
    $$ language 'plpgsql';

    DROP TRIGGER IF EXISTS update_users_updated_at ON users;
    CREATE TRIGGER update_users_updated_at BEFORE UPDATE
        ON users FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  `;

  try {
    console.log('Running migration...');
    
    // Split the SQL into individual statements and run them
    const statements = createUsersTableSQL
      .split(';')
      .map(s => s.trim())
      .filter(s => s.length > 0);

    for (const statement of statements) {
      if (statement.trim()) {
        console.log(`Executing: ${statement.substring(0, 50)}...`);
        const { data, error } = await supabase.rpc('exec_sql', { sql: statement });
        
        if (error) {
          console.error('Error executing statement:', error);
          // Try using raw SQL if rpc fails
          const { data: rawData, error: rawError } = await supabase
            .from('pg_stat_statements')
            .select('*');
          
          if (rawError && rawError.message.includes('does not exist')) {
            console.log('Table does not exist yet, continuing...');
          }
        } else {
          console.log('Success:', statement.substring(0, 30));
        }
      }
    }
    
    console.log('Migration completed successfully!');
    
    // Verify table exists
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .limit(1);
    
    if (error && error.code === 'PGRST116') {
      console.log('Table created successfully but no data yet');
    } else if (error) {
      console.error('Error verifying table:', error);
    } else {
      console.log('Table verified successfully!');
    }
    
  } catch (error) {
    console.error('Migration failed:', error);
  }
}

runMigration();
